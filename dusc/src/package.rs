use anyhow::{bail, Context, Result};
use ast::AstNode;
use parser::Parser;
use std::{collections::HashMap, fs, path::PathBuf};

// This will need to be moved into a different file at some point.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DuskPath<'i> {
    Root,
    Name(&'i str),
    Member {
        left: Box<DuskPath<'i>>,
        right: Box<DuskPath<'i>>,
    },
    Scope {
        left: Box<DuskPath<'i>>,
        right: Box<DuskPath<'i>>,
    },
}

#[derive(Debug)]
pub enum PackageKind {
    Binary,
    Library,
}

impl PackageKind {
    pub fn filename(&self) -> &'static str {
        match self {
            PackageKind::Binary => "main.dusk",
            PackageKind::Library => "lib.dusk",
        }
    }
}

// This will also need to be moved in the future.
#[derive(Debug)]
pub enum Item<'i> {
    Module(Module<'i>),
    // ...
}

#[derive(Debug)]
pub struct Module<'i> {
    source: &'static String,
    ast: Vec<AstNode<'i>>,
}

// This is incredibly, incredibly unsafe. There is no greater evil than this, and yet.
impl<'i> Drop for Module<'i> {
    fn drop(&mut self) {
        unsafe {
            Box::from_raw(self.source as *const String as *mut String);
        }
    }
}

#[derive(Debug)]
pub struct Package<'i> {
    kind: PackageKind,
    namespace: HashMap<DuskPath<'i>, Item<'i>>,
}

impl<'i> Package<'i> {
    pub fn new(kind: PackageKind) -> Self {
        Package {
            kind,
            namespace: HashMap::new(),
        }
    }

    pub fn build_module_tree(&mut self, path: PathBuf) -> Result<()> {
        let root_module = self.module_tree(path, DuskPath::Root)?;
        self.namespace
            .insert(DuskPath::Root, Item::Module(root_module));

        Ok(())
    }

    fn module_tree(&mut self, mut path: PathBuf, parent: DuskPath<'i>) -> Result<Module<'i>> {
        // If we're a directory, we can assume we're at the package root. As such we need to figure out our entry point.
        if path.is_dir() {
            path.push(self.kind.filename());
            return self.module_tree(path, DuskPath::Root);
        }

        // This early return will also catch issues with the file not existing. I'm not sure about whether we should
        // catch that here or earlier. Guess we'll see.

        // We need to leak this data here so that we can rely on `&str`s generated by the parser being valid.
        let contents: &'static String = Box::leak(Box::new(
            fs::read_to_string(&path)
                .with_context(|| format!("Could not open {}", path.to_string_lossy()))
                .context("Unresolved module")?,
        ));

        let parse_result = Parser::new(contents).parse()?;

        // Module declarations are items (top-level statements) so we can just filter like so to check if we need to
        // parse anything else. In the future this may change but for now our lives are easy.
        let submodules = parse_result.iter().filter_map(|node| match node {
            AstNode::Module(name) => Some(name),
            _ => None,
        });

        for submodule_name in submodules {
            let submodule_path = DuskPath::Scope {
                left: Box::new(parent.clone()),
                right: Box::new(DuskPath::Name(submodule_name)),
            };

            // TODO: Nicer error. I'd like to somehow point to a code snippet and a path in the future. This is okay
            // for the moment though.
            if self.namespace.contains_key(&submodule_path) {
                bail!("Module {} declared multiple times", submodule_name)
            }

            let current_level = path.with_file_name(&format!("{}.dusk", submodule_name));
            let mut level_down = path.clone();
            level_down.pop();
            level_down.push(format!("{}/module.dusk", submodule_name));

            println!("{:?} and {:?}", &current_level, &level_down);

            let submodule = match (current_level.exists(), level_down.exists()) {
                (true, false) => self.module_tree(current_level, parent.clone())?,
                (false, true) => self.module_tree(level_down, submodule_path.clone())?,
                _ => bail!("Unresolved module"),
            };

            self.namespace
                .insert(submodule_path, Item::Module(submodule));
        }

        let result = Module {
            source: contents,
            ast: parse_result,
        };

        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // I had a pretty basic local test set up here and It Worked :tm:. I'll get an actual good test up on GH soon-ish.
    // I am currently quite sleep-deprived.
    #[test]
    pub fn test_resolve() -> Result<()> {
        let mut package = Package::new(PackageKind::Binary);
        package.build_module_tree(PathBuf::from("..."))
    }
}
